import discord
from discord.ext import commands, tasks
import json
import re
import asyncio
from datetime import datetime, timedelta
import os
from typing import Dict, List, Optional, Tuple

class SocialMediaLinksManager(commands.Cog):
    """
    Cog pour d√©tecter et g√©rer les liens de r√©seaux sociaux
    Maintient un embed fixe par canal avec les liens d√©tect√©s
    """
    
    def __init__(self, bot):
        self.bot = bot
        self.data_file = "social_links_data.json"
        self.embed_messages_file = "embed_messages.json"
        
        # Configuration des plateformes support√©es
        self.site_configs = {
            "twitter": {
                "patterns": [
                    r"https?://(?:www\.)?(?:twitter\.com|x\.com)/(\w+)/status/(\d+)",
                    r"https?://(?:mobile\.)?(?:twitter\.com|x\.com)/(\w+)/status/(\d+)",
                ],
                "alternative_template": "https://fxtwitter.com/{}/status/{}",
                "emoji": "üê¶",
                "name": "Twitter/X"
            },
            "instagram_post": {
                "patterns": [
                    r"https?://(?:www\.)?instagram\.com/p/([\w-]+)/?",
                ],
                "alternative_template": "https://ddinstagram.com/p/{}",
                "emoji": "üì∏",
                "name": "Instagram Post"
            },
            "instagram_reel": {
                "patterns": [
                    r"https?://(?:www\.)?instagram\.com/reel/([\w-]+)/?",
                ],
                "alternative_template": "https://ddinstagram.com/reel/{}",
                "emoji": "üé¨",
                "name": "Instagram Reel"
            },
            "tiktok": {
                "patterns": [
                    r"https?://(?:www|vm|m)\.tiktok\.com/t/([^/]+)/?",
                    r"https?://(?:www|vm|m)\.tiktok\.com/@[\w.-]+/video/(\d+)",
                ],
                "alternative_template": "https://tnktok.com/t/{}",
                "emoji": "üéµ",
                "name": "TikTok"
            },
            "youtube_shorts": {
                "patterns": [
                    r"https?://(?:www\.)?youtube\.com/shorts/([\w-]+)",
                ],
                "alternative_template": "https://youtube.com/watch?v={}",
                "emoji": "üé•",
                "name": "YouTube Shorts"
            },
            "reddit": {
                "patterns": [
                    r"https?://(?:www\.|old\.)?reddit\.com/r/([\w-]+)/comments/([\w-]+)",
                ],
                "alternative_template": "https://rxddit.com/r/{}/comments/{}",
                "emoji": "üî¥",
                "name": "Reddit"
            }
        }
        
        # Chargement des donn√©es au d√©marrage
        self.links_data = self.load_data()
        self.embed_messages = self.load_embed_messages()
        
        # D√©marrage de la t√¢che de nettoyage automatique
        self.cleanup_task.start()
    
    def load_data(self) -> Dict:
        """Charge les donn√©es des liens depuis le fichier JSON"""
        try:
            if os.path.exists(self.data_file):
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Erreur lors du chargement des donn√©es: {e}")
        return {}
    
    def save_data(self) -> None:
        """Sauvegarde les donn√©es des liens dans le fichier JSON"""
        try:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(self.links_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erreur lors de la sauvegarde des donn√©es: {e}")
    
    def load_embed_messages(self) -> Dict:
        """Charge les IDs des messages d'embed par canal"""
        try:
            if os.path.exists(self.embed_messages_file):
                with open(self.embed_messages_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Erreur lors du chargement des embeds: {e}")
        return {}
    
    def save_embed_messages(self) -> None:
        """Sauvegarde les IDs des messages d'embed"""
        try:
            with open(self.embed_messages_file, 'w', encoding='utf-8') as f:
                json.dump(self.embed_messages, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Erreur lors de la sauvegarde des embeds: {e}")
    
    def detect_social_link(self, text: str) -> Optional[Tuple[str, str, List[str]]]:
        """
        D√©tecte les liens de r√©seaux sociaux dans le texte
        Returns: (platform, original_url, extracted_groups) ou None
        """
        for platform, config in self.site_configs.items():
            for pattern in config["patterns"]:
                match = re.search(pattern, text)
                if match:
                    return platform, match.group(0), list(match.groups())
        return None
    
    def generate_alternative_url(self, platform: str, groups: List[str]) -> str:
        """G√©n√®re l'URL alternative bas√©e sur la plateforme et les groupes extraits"""
        config = self.site_configs[platform]
        
        # Gestion sp√©ciale pour Reddit (2 groupes)
        if platform == "reddit" and len(groups) >= 2:
            return config["alternative_template"].format(groups[0], groups[1])
        
        # Gestion sp√©ciale pour Twitter (2 groupes)
        elif platform == "twitter" and len(groups) >= 2:
            return config["alternative_template"].format(groups[0], groups[1])
        
        # Gestion standard pour les autres plateformes (1 groupe)
        elif len(groups) >= 1:
            return config["alternative_template"].format(groups[0])
        
        return config["alternative_template"].format(*groups)
    
    def get_link_identifier(self, platform: str, groups: List[str]) -> str:
        """G√©n√®re un identifiant unique pour le lien bas√© sur la plateforme"""
        if platform == "reddit" and len(groups) >= 2:
            return f"{platform}_{groups[0]}_{groups[1]}"
        elif platform == "twitter" and len(groups) >= 2:
            return f"{platform}_{groups[0]}_{groups[1]}"
        elif len(groups) >= 1:
            return f"{platform}_{groups[0]}"
        return f"{platform}_{'_'.join(groups)}"
    
    def is_duplicate_link(self, channel_id: str, link_identifier: str) -> bool:
        """V√©rifie si un lien est d√©j√† pr√©sent dans ce canal"""
        if channel_id not in self.links_data:
            return False
        
        for link_data in self.links_data[channel_id]:
            if link_data.get("identifier") == link_identifier:
                return True
        return False
    
    def add_link_to_data(self, channel_id: str, link_data: Dict) -> None:
        """Ajoute un lien aux donn√©es du canal"""
        if channel_id not in self.links_data:
            self.links_data[channel_id] = []
        
        self.links_data[channel_id].append(link_data)
        self.save_data()
    
    def create_embed(self, channel_id: str) -> discord.Embed:
        """Cr√©e l'embed avec tous les liens du canal"""
        embed = discord.Embed(
            title="üîó Liens de R√©seaux Sociaux",
            description="Liens d√©tect√©s dans ce canal (derni√®res 24h)",
            color=discord.Color.blue(),
            timestamp=datetime.utcnow()
        )
        
        if channel_id not in self.links_data or not self.links_data[channel_id]:
            embed.add_field(
                name="Aucun lien",
                value="Aucun lien d√©tect√© pour le moment",
                inline=False
            )
            return embed
        
        # Grouper les liens par plateforme
        platforms = {}
        for link_data in self.links_data[channel_id]:
            platform = link_data["platform"]
            if platform not in platforms:
                platforms[platform] = []
            platforms[platform].append(link_data)
        
        # Ajouter les liens group√©s par plateforme
        for platform, links in platforms.items():
            config = self.site_configs[platform]
            value = ""
            for link_data in links[-5:]:  # Limiter √† 5 liens par plateforme
                alt_url = link_data["alternative_url"]
                author = link_data["author"]
                value += f"‚Ä¢ [Lien]({alt_url}) - par <@{author}>\n"
            
            if len(links) > 5:
                value += f"... et {len(links) - 5} autres liens\n"
            
            embed.add_field(
                name=f"{config['emoji']} {config['name']} ({len(links)})",
                value=value or "Aucun lien",
                inline=False
            )
        
        embed.set_footer(text=f"Total: {sum(len(links) for links in platforms.values())} liens")
        return embed
    
    async def create_response_embed(self, platform: str, alternative_url: str, author: discord.Member) -> discord.Embed:
        """Cr√©e un embed de r√©ponse pour le lien d√©tect√©"""
        config = self.site_configs[platform]
        
        embed = discord.Embed(
            title=f"{config['emoji']} {config['name']} d√©tect√©",
            description=f"Lien partag√© par {author.mention}",
            color=discord.Color.green(),
            timestamp=datetime.utcnow()
        )
        
        embed.add_field(
            name="üîó Lien alternatif",
            value=f"[Cliquez ici pour acc√©der au contenu]({alternative_url})",
            inline=False
        )
        
        embed.add_field(
            name="‚ÑπÔ∏è Informations",
            value="Le message original a √©t√© remplac√© par ce lien alternatif pour une meilleure exp√©rience.",
            inline=False
        )
        
        embed.set_thumbnail(url=author.display_avatar.url)
        embed.set_footer(text=f"Partag√© par {author.display_name}")
        
        return embed
    
    async def update_or_create_embed(self, channel) -> None:
        """Met √† jour ou cr√©e l'embed dans le canal"""
        try:
            channel_id = str(channel.id)
            embed = self.create_embed(channel_id)
            
            # V√©rifier si un message d'embed existe d√©j√†
            if channel_id in self.embed_messages:
                try:
                    message = await channel.fetch_message(self.embed_messages[channel_id])
                    await message.edit(embed=embed)
                    return
                except discord.NotFound:
                    # Le message n'existe plus, en cr√©er un nouveau
                    del self.embed_messages[channel_id]
            
            # Cr√©er un nouveau message d'embed
            message = await channel.send(embed=embed)
            self.embed_messages[channel_id] = message.id
            self.save_embed_messages()
            
        except Exception as e:
            print(f"Erreur lors de la mise √† jour de l'embed: {e}")
    
    async def send_duplicate_warning(self, channel, author: discord.Member, platform: str) -> None:
        """Envoie un message d'avertissement pour les doublons"""
        config = self.site_configs[platform]
        
        embed = discord.Embed(
            title="‚ö†Ô∏è Lien d√©j√† partag√©",
            description=f"{author.mention}, ce lien de **{config['name']}** a d√©j√† √©t√© partag√© dans ce canal !",
            color=discord.Color.orange(),
            timestamp=datetime.utcnow()
        )
        
        embed.add_field(
            name="üí° Conseil",
            value="V√©rifiez l'embed des liens d√©j√† partag√©s dans ce canal avant de poster.",
            inline=False
        )
        
        embed.set_thumbnail(url=author.display_avatar.url)
        embed.set_footer(text="Ce message se supprimera automatiquement dans 15 secondes")
        
        # Envoyer le message et le supprimer apr√®s 15 secondes
        warning_message = await channel.send(embed=embed)
        await asyncio.sleep(15)
        try:
            await warning_message.delete()
        except discord.NotFound:
            pass  # Le message a d√©j√† √©t√© supprim√©
    
    @commands.Cog.listener()
    async def on_message(self, message):
        """Listener principal pour d√©tecter les liens dans les messages"""
        # Ignorer les messages du bot
        if message.author.bot:
            return
        
        # V√©rifier les permissions du bot dans le canal
        permissions = message.channel.permissions_for(message.guild.me)
        if not (permissions.send_messages and permissions.manage_messages and permissions.embed_links):
            return
        
        # D√©tecter les liens de r√©seaux sociaux
        detection_result = self.detect_social_link(message.content)
        if not detection_result:
            return
        
        platform, original_url, groups = detection_result
        channel_id = str(message.channel.id)
        
        # G√©n√©rer l'identifiant unique du lien
        link_identifier = self.get_link_identifier(platform, groups)
        
        # V√©rifier si c'est un doublon
        if self.is_duplicate_link(channel_id, link_identifier):
            # Supprimer le message original
            try:
                await message.delete()
            except discord.NotFound:
                pass  # Le message a d√©j√† √©t√© supprim√©
            except discord.Forbidden:
                print(f"Permissions insuffisantes pour supprimer le message dans {message.channel.name}")
            
            # Envoyer l'avertissement de doublon
            await self.send_duplicate_warning(message.channel, message.author, platform)
            return
        
        # G√©n√©rer l'URL alternative
        alternative_url = self.generate_alternative_url(platform, groups)
        
        # Supprimer le message original en premier
        try:
            await message.delete()
        except discord.NotFound:
            pass  # Le message a d√©j√† √©t√© supprim√©
        except discord.Forbidden:
            print(f"Permissions insuffisantes pour supprimer le message dans {message.channel.name}")
            # Si on ne peut pas supprimer, on continue quand m√™me
        
        # Cr√©er l'embed de r√©ponse
        response_embed = await self.create_response_embed(platform, alternative_url, message.author)
        
        # Envoyer l'embed de r√©ponse
        await message.channel.send(embed=response_embed)
        
        # Ajouter le lien aux donn√©es
        link_data = {
            "identifier": link_identifier,
            "platform": platform,
            "original_url": original_url,
            "alternative_url": alternative_url,
            "author": message.author.id,
            "timestamp": datetime.utcnow().isoformat(),
            "channel_id": channel_id
        }
        
        self.add_link_to_data(channel_id, link_data)
        
        # Mettre √† jour l'embed fixe  
        await self.update_or_create_embed(message.channel)
    
    @tasks.loop(hours=24)
    async def cleanup_task(self):
        """Nettoie automatiquement les liens plus anciens que 24 heures"""
        print("üßπ D√©but du nettoyage automatique des liens...")
        
        current_time = datetime.utcnow()
        channels_to_update = set()
        
        # Nettoyer les donn√©es
        for channel_id, links in list(self.links_data.items()):
            original_count = len(links)
            
            # Filtrer les liens de moins de 24 heures
            self.links_data[channel_id] = [
                link for link in links
                if current_time - datetime.fromisoformat(link["timestamp"]) < timedelta(hours=24)
            ]
            
            # Si des liens ont √©t√© supprim√©s, marquer le canal pour mise √† jour
            if len(self.links_data[channel_id]) != original_count:
                channels_to_update.add(channel_id)
            
            # Supprimer les canaux vides
            if not self.links_data[channel_id]:
                del self.links_data[channel_id]
        
        # Sauvegarder les donn√©es nettoy√©es
        self.save_data()
        
        # Mettre √† jour les embeds des canaux concern√©s
        for channel_id in channels_to_update:
            try:
                channel = self.bot.get_channel(int(channel_id))
                if channel:
                    await self.update_or_create_embed(channel)
            except Exception as e:
                print(f"Erreur lors de la mise √† jour de l'embed du canal {channel_id}: {e}")
        
        print(f"‚úÖ Nettoyage termin√©. {len(channels_to_update)} canaux mis √† jour.")
    
    @cleanup_task.before_loop
    async def before_cleanup(self):
        """Attend que le bot soit pr√™t avant de d√©marrer le nettoyage"""
        await self.bot.wait_until_ready()
    
    
    @commands.command(name="force_cleanup")
    @commands.has_permissions(manage_messages=True)
    async def force_cleanup_command(self, ctx):
        """Commande pour forcer le nettoyage des liens (admin uniquement)"""
        await ctx.send("üßπ D√©marrage du nettoyage forc√©...")
        await self.cleanup_task()
        await ctx.send("‚úÖ Nettoyage forc√© termin√© !")
    
    @commands.command(name="links_stats")
    async def links_stats(self, ctx):
        """Affiche les statistiques des liens d√©tect√©s"""
        channel_id = str(ctx.channel.id)
        
        if channel_id not in self.links_data or not self.links_data[channel_id]:
            await ctx.send("‚ùå Aucun lien d√©tect√© dans ce canal.")
            return
        
        # Compter les liens par plateforme
        platform_counts = {}
        for link_data in self.links_data[channel_id]:
            platform = link_data["platform"]
            platform_counts[platform] = platform_counts.get(platform, 0) + 1
        
        # Cr√©er l'embed des statistiques
        embed = discord.Embed(
            title="üìä Statistiques des Liens",
            description=f"Statistiques pour {ctx.channel.mention}",
            color=discord.Color.green()
        )
        
        for platform, count in platform_counts.items():
            config = self.site_configs[platform]
            embed.add_field(
                name=f"{config['emoji']} {config['name']}",
                value=f"{count} lien{'s' if count > 1 else ''}",
                inline=True
            )
        
        total_links = sum(platform_counts.values())
        embed.set_footer(text=f"Total: {total_links} liens d√©tect√©s")
        
        await ctx.send(embed=embed)

async def setup(bot):
    """Fonction de setup pour charger le cog"""
    await bot.add_cog(SocialMediaLinksManager(bot))
